package Controllers;

import Models.BinarySequenceGenerator;
import Models.CodeGenerator;
import Views.HelpInformation;
import core.ByteController;
import core.CodeController;
import core.GammingController;
import core.StringController;

import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;

public class ThreadController {
    ArrayBlockingQueue<Boolean> qBinSeq;
    ArrayBlockingQueue<Long> qLongCode;
    ArrayBlockingQueue<List<Byte>> qBytesCode;

    ArrayBlockingQueue<List<Byte>> qBytesStr;

    ArrayList<String> splittedInput;
    private ArrayList<String> resultString;

    private BinarySequenceGenerator binSeqGen;
    private CodeGenerator codeGen;
    private int size;

    public ThreadController(BinarySequenceGenerator binSeqGen, CodeGenerator codeGen, ArrayList<String> splittedInput) {
        this.binSeqGen = binSeqGen;
        this.codeGen = codeGen;
        this.splittedInput = splittedInput;
        this.size = this.splittedInput.size();
        this.qBinSeq = new ArrayBlockingQueue<>(this.size);
        this.qLongCode = new ArrayBlockingQueue<>(this.size);
        this.qBytesCode = new ArrayBlockingQueue<List<Byte>>(this.size*3);
        this.qBytesStr = new ArrayBlockingQueue<List<Byte>>(this.size*3);
        this.resultString = new ArrayList<>();
    }

    public void start() {

        // Generate one binary sequence
        new Thread() {
            @Override
            public void run() {
                for (int i = 0; i < size; i++) {
                    boolean sequence = binSeqGen.generateRecurrenceSequence();
                    qBinSeq.add(sequence);
                    HelpInformation.setMessageBin("[+] Bit of binary sequence -> " + (sequence ? 1 : 0));

                }
            }
        }.start();

        // Get one binary sequence and get inverted or not inverted code
        new Thread() {
            @Override
            public void run() {
                for (int i = 0; i < size; i++) {
                    try {
                        long num = qBinSeq.take() ?
                                CodeController.invertNumber(codeGen.generateCodeLong()) :
                                codeGen.generateCodeLong();
                        qLongCode.add(num);
                        HelpInformation.setMessageLong("[?] long number -> " + num +
                                "\n[=> Binary representation of number  <---------++--------> "
                                + StringController.bytesToBinaryString(
                                ByteController.getBytesFromLong(num, CodeGenerator.NUM_BIT_LENGTH)) +
                                "\n[=> Binary representation of Inverted version of number -> "
                                + StringController.bytesToBinaryString(
                                ByteController.getBytesFromLong(
                                        CodeController.invertNumber(num), CodeGenerator.NUM_BIT_LENGTH)));

                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        }.start();

        // Get one long code and get bytes from it
        new Thread() {
            @Override
            public void run() {
                for (String temp : splittedInput) {
                    try {
                        List<Byte> tempArr = ByteController.getBytesFromLong(qLongCode.take(), temp.length());
                        qBytesCode.add(tempArr);
                        HelpInformation.setMessageByteCode("[+] generated Byte array of Long number " + tempArr);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        }.start();

        // Get n bytes from string
        new Thread() {
            @Override
            public void run() {
                for (String temp : splittedInput) {
                    List<Byte> tempArr = ByteController.getBytesFromString(temp); // (ByteController.getBytesFromString(temp);
                    qBytesStr.add(tempArr);
                    HelpInformation.setMessageByteStr("[+] Generated byte array of string " + tempArr +
                            "\n[?] Binary representation of string -> " + StringController.bytesToBinaryString(tempArr));
                }
            }
        }.start();

        // Crypt n bytes of String and Code
        new Thread() {
            @Override
            public void run() {
                for (String temp : splittedInput) {
                    try {
                        List<Byte> codeBytes = qBytesCode.take();
                        List<Byte> strBytes = qBytesStr.take();
                        String resStr = GammingController.cryptString(strBytes, codeBytes);
                        resultString.add(resStr);

                        HelpInformation.setMessageCrypted("[?] Binary form of code ->           "
                                + StringController.bytesToBinaryString(codeBytes) +
                                "\n[?] Binary form of string ->         "
                                + StringController.bytesToBinaryString(strBytes) +
                                "\n[?] Binary form of crypted string -> "
                                + StringController.bytesToBinaryString(ByteController.getBytesFromString(resStr)) +
                                "\n[+] Crypted string -> " + resStr +
                                "\n+--------------------------------------------------------------------------------+");

                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                HelpInformation.display();
                System.out.println("[*] Result output: " + String.join("", resultString));

            }

        }.start();

    }

    public ArrayList<String> getResultString() {
        return resultString;
    }
}